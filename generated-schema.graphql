# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type Actions {
  Notifications(cursor: NotificationsWhereUniqueInput, distinct: [NotificationsScalarFieldEnum!], orderBy: [NotificationsOrderByWithRelationInput!], skip: Int, take: Int, where: NotificationsWhereInput): [Notifications!]!
  Tasks: Tasks!
  _count: ActionsCount
  id: ID!
  name: Name
  targetId: String!
  targetType: TargetType
}

type ActionsCount {
  Notifications: Int!
}

type ActionsCountAggregate {
  _all: Int!
  id: Int!
  name: Int!
  targetId: Int!
  targetType: Int!
}

input ActionsCountOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  targetId: SortOrder
  targetType: SortOrder
}

input ActionsCreateInput {
  Notifications: NotificationsCreateNestedManyWithoutActionsInput
  Tasks: TasksCreateNestedOneWithoutActionsInput!
  id: String
  name: Name
  targetType: TargetType
}

input ActionsCreateManyInput {
  id: String
  name: Name
  targetId: String!
  targetType: TargetType
}

input ActionsCreateManyTasksInput {
  id: String
  name: Name
  targetType: TargetType
}

input ActionsCreateManyTasksInputEnvelope {
  data: [ActionsCreateManyTasksInput!]!
  skipDuplicates: Boolean
}

input ActionsCreateNestedManyWithoutTasksInput {
  connect: [ActionsWhereUniqueInput!]
  connectOrCreate: [ActionsCreateOrConnectWithoutTasksInput!]
  create: [ActionsCreateWithoutTasksInput!]
  createMany: ActionsCreateManyTasksInputEnvelope
}

input ActionsCreateNestedOneWithoutNotificationsInput {
  connect: ActionsWhereUniqueInput
  connectOrCreate: ActionsCreateOrConnectWithoutNotificationsInput
  create: ActionsCreateWithoutNotificationsInput
}

input ActionsCreateOrConnectWithoutNotificationsInput {
  create: ActionsCreateWithoutNotificationsInput!
  where: ActionsWhereUniqueInput!
}

input ActionsCreateOrConnectWithoutTasksInput {
  create: ActionsCreateWithoutTasksInput!
  where: ActionsWhereUniqueInput!
}

input ActionsCreateWithoutNotificationsInput {
  Tasks: TasksCreateNestedOneWithoutActionsInput!
  id: String
  name: Name
  targetType: TargetType
}

input ActionsCreateWithoutTasksInput {
  Notifications: NotificationsCreateNestedManyWithoutActionsInput
  id: String
  name: Name
  targetType: TargetType
}

type ActionsGroupBy {
  _count: ActionsCountAggregate
  _max: ActionsMaxAggregate
  _min: ActionsMinAggregate
  id: String!
  name: Name
  targetId: String!
  targetType: TargetType
}

input ActionsListRelationFilter {
  every: ActionsWhereInput
  none: ActionsWhereInput
  some: ActionsWhereInput
}

type ActionsMaxAggregate {
  id: String
  name: Name
  targetId: String
  targetType: TargetType
}

input ActionsMaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  targetId: SortOrder
  targetType: SortOrder
}

type ActionsMinAggregate {
  id: String
  name: Name
  targetId: String
  targetType: TargetType
}

input ActionsMinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  targetId: SortOrder
  targetType: SortOrder
}

input ActionsOrderByRelationAggregateInput {
  _count: SortOrder
}

input ActionsOrderByWithAggregationInput {
  _count: ActionsCountOrderByAggregateInput
  _max: ActionsMaxOrderByAggregateInput
  _min: ActionsMinOrderByAggregateInput
  id: SortOrder
  name: SortOrder
  targetId: SortOrder
  targetType: SortOrder
}

input ActionsOrderByWithRelationInput {
  Notifications: NotificationsOrderByRelationAggregateInput
  Tasks: TasksOrderByWithRelationInput
  id: SortOrder
  name: SortOrder
  targetId: SortOrder
  targetType: SortOrder
}

input ActionsRelationFilter {
  is: ActionsWhereInput
  isNot: ActionsWhereInput
}

enum ActionsScalarFieldEnum {
  id
  name
  targetId
  targetType
}

input ActionsScalarWhereInput {
  AND: [ActionsScalarWhereInput!]
  NOT: [ActionsScalarWhereInput!]
  OR: [ActionsScalarWhereInput!]
  id: StringFilter
  name: EnumNameNullableFilter
  targetId: StringFilter
  targetType: EnumTargetTypeNullableFilter
}

input ActionsScalarWhereWithAggregatesInput {
  AND: [ActionsScalarWhereWithAggregatesInput!]
  NOT: [ActionsScalarWhereWithAggregatesInput!]
  OR: [ActionsScalarWhereWithAggregatesInput!]
  id: StringWithAggregatesFilter
  name: EnumNameNullableWithAggregatesFilter
  targetId: StringWithAggregatesFilter
  targetType: EnumTargetTypeNullableWithAggregatesFilter
}

input ActionsUpdateInput {
  Notifications: NotificationsUpdateManyWithoutActionsNestedInput
  Tasks: TasksUpdateOneRequiredWithoutActionsNestedInput
  id: StringFieldUpdateOperationsInput
  name: NullableEnumNameFieldUpdateOperationsInput
  targetType: NullableEnumTargetTypeFieldUpdateOperationsInput
}

input ActionsUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  name: NullableEnumNameFieldUpdateOperationsInput
  targetType: NullableEnumTargetTypeFieldUpdateOperationsInput
}

input ActionsUpdateManyWithWhereWithoutTasksInput {
  data: ActionsUpdateManyMutationInput!
  where: ActionsScalarWhereInput!
}

input ActionsUpdateManyWithoutTasksNestedInput {
  connect: [ActionsWhereUniqueInput!]
  connectOrCreate: [ActionsCreateOrConnectWithoutTasksInput!]
  create: [ActionsCreateWithoutTasksInput!]
  createMany: ActionsCreateManyTasksInputEnvelope
  delete: [ActionsWhereUniqueInput!]
  deleteMany: [ActionsScalarWhereInput!]
  disconnect: [ActionsWhereUniqueInput!]
  set: [ActionsWhereUniqueInput!]
  update: [ActionsUpdateWithWhereUniqueWithoutTasksInput!]
  updateMany: [ActionsUpdateManyWithWhereWithoutTasksInput!]
  upsert: [ActionsUpsertWithWhereUniqueWithoutTasksInput!]
}

input ActionsUpdateOneRequiredWithoutNotificationsNestedInput {
  connect: ActionsWhereUniqueInput
  connectOrCreate: ActionsCreateOrConnectWithoutNotificationsInput
  create: ActionsCreateWithoutNotificationsInput
  update: ActionsUpdateWithoutNotificationsInput
  upsert: ActionsUpsertWithoutNotificationsInput
}

input ActionsUpdateWithWhereUniqueWithoutTasksInput {
  data: ActionsUpdateWithoutTasksInput!
  where: ActionsWhereUniqueInput!
}

input ActionsUpdateWithoutNotificationsInput {
  Tasks: TasksUpdateOneRequiredWithoutActionsNestedInput
  id: StringFieldUpdateOperationsInput
  name: NullableEnumNameFieldUpdateOperationsInput
  targetType: NullableEnumTargetTypeFieldUpdateOperationsInput
}

input ActionsUpdateWithoutTasksInput {
  Notifications: NotificationsUpdateManyWithoutActionsNestedInput
  id: StringFieldUpdateOperationsInput
  name: NullableEnumNameFieldUpdateOperationsInput
  targetType: NullableEnumTargetTypeFieldUpdateOperationsInput
}

input ActionsUpsertWithWhereUniqueWithoutTasksInput {
  create: ActionsCreateWithoutTasksInput!
  update: ActionsUpdateWithoutTasksInput!
  where: ActionsWhereUniqueInput!
}

input ActionsUpsertWithoutNotificationsInput {
  create: ActionsCreateWithoutNotificationsInput!
  update: ActionsUpdateWithoutNotificationsInput!
}

input ActionsWhereInput {
  AND: [ActionsWhereInput!]
  NOT: [ActionsWhereInput!]
  Notifications: NotificationsListRelationFilter
  OR: [ActionsWhereInput!]
  Tasks: TasksRelationFilter
  id: StringFilter
  name: EnumNameNullableFilter
  targetId: StringFilter
  targetType: EnumTargetTypeNullableFilter
}

input ActionsWhereUniqueInput {
  id: String
}

type AffectedRowsOutput {
  count: Int!
}

type AggregateActions {
  _count: ActionsCountAggregate
  _max: ActionsMaxAggregate
  _min: ActionsMinAggregate
}

type AggregateAssignees {
  _count: AssigneesCountAggregate
  _max: AssigneesMaxAggregate
  _min: AssigneesMinAggregate
}

type AggregateComments {
  _count: CommentsCountAggregate
  _max: CommentsMaxAggregate
  _min: CommentsMinAggregate
}

type AggregateNotifications {
  _count: NotificationsCountAggregate
  _max: NotificationsMaxAggregate
  _min: NotificationsMinAggregate
}

type AggregateTasks {
  _count: TasksCountAggregate
  _max: TasksMaxAggregate
  _min: TasksMinAggregate
}

type AggregateUser {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
}

type Assignees {
  Tasks: Tasks!
  User: User!
  id: ID!
  tasksId: String!
  userId: String!
}

type AssigneesCountAggregate {
  _all: Int!
  id: Int!
  tasksId: Int!
  userId: Int!
}

input AssigneesCountOrderByAggregateInput {
  id: SortOrder
  tasksId: SortOrder
  userId: SortOrder
}

input AssigneesCreateInput {
  Tasks: TasksCreateNestedOneWithoutAssigneesInput!
  User: UserCreateNestedOneWithoutAssigneesInput!
  id: String
}

input AssigneesCreateManyInput {
  id: String
  tasksId: String!
  userId: String!
}

input AssigneesCreateManyTasksInput {
  id: String
  userId: String!
}

input AssigneesCreateManyTasksInputEnvelope {
  data: [AssigneesCreateManyTasksInput!]!
  skipDuplicates: Boolean
}

input AssigneesCreateManyUserInput {
  id: String
  tasksId: String!
}

input AssigneesCreateManyUserInputEnvelope {
  data: [AssigneesCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input AssigneesCreateNestedManyWithoutTasksInput {
  connect: [AssigneesWhereUniqueInput!]
  connectOrCreate: [AssigneesCreateOrConnectWithoutTasksInput!]
  create: [AssigneesCreateWithoutTasksInput!]
  createMany: AssigneesCreateManyTasksInputEnvelope
}

input AssigneesCreateNestedManyWithoutUserInput {
  connect: [AssigneesWhereUniqueInput!]
  connectOrCreate: [AssigneesCreateOrConnectWithoutUserInput!]
  create: [AssigneesCreateWithoutUserInput!]
  createMany: AssigneesCreateManyUserInputEnvelope
}

input AssigneesCreateOrConnectWithoutTasksInput {
  create: AssigneesCreateWithoutTasksInput!
  where: AssigneesWhereUniqueInput!
}

input AssigneesCreateOrConnectWithoutUserInput {
  create: AssigneesCreateWithoutUserInput!
  where: AssigneesWhereUniqueInput!
}

input AssigneesCreateWithoutTasksInput {
  User: UserCreateNestedOneWithoutAssigneesInput!
  id: String
}

input AssigneesCreateWithoutUserInput {
  Tasks: TasksCreateNestedOneWithoutAssigneesInput!
  id: String
}

type AssigneesGroupBy {
  _count: AssigneesCountAggregate
  _max: AssigneesMaxAggregate
  _min: AssigneesMinAggregate
  id: String!
  tasksId: String!
  userId: String!
}

input AssigneesListRelationFilter {
  every: AssigneesWhereInput
  none: AssigneesWhereInput
  some: AssigneesWhereInput
}

type AssigneesMaxAggregate {
  id: String
  tasksId: String
  userId: String
}

input AssigneesMaxOrderByAggregateInput {
  id: SortOrder
  tasksId: SortOrder
  userId: SortOrder
}

type AssigneesMinAggregate {
  id: String
  tasksId: String
  userId: String
}

input AssigneesMinOrderByAggregateInput {
  id: SortOrder
  tasksId: SortOrder
  userId: SortOrder
}

input AssigneesOrderByRelationAggregateInput {
  _count: SortOrder
}

input AssigneesOrderByWithAggregationInput {
  _count: AssigneesCountOrderByAggregateInput
  _max: AssigneesMaxOrderByAggregateInput
  _min: AssigneesMinOrderByAggregateInput
  id: SortOrder
  tasksId: SortOrder
  userId: SortOrder
}

input AssigneesOrderByWithRelationInput {
  Tasks: TasksOrderByWithRelationInput
  User: UserOrderByWithRelationInput
  id: SortOrder
  tasksId: SortOrder
  userId: SortOrder
}

enum AssigneesScalarFieldEnum {
  id
  tasksId
  userId
}

input AssigneesScalarWhereInput {
  AND: [AssigneesScalarWhereInput!]
  NOT: [AssigneesScalarWhereInput!]
  OR: [AssigneesScalarWhereInput!]
  id: StringFilter
  tasksId: StringFilter
  userId: StringFilter
}

input AssigneesScalarWhereWithAggregatesInput {
  AND: [AssigneesScalarWhereWithAggregatesInput!]
  NOT: [AssigneesScalarWhereWithAggregatesInput!]
  OR: [AssigneesScalarWhereWithAggregatesInput!]
  id: StringWithAggregatesFilter
  tasksId: StringWithAggregatesFilter
  userId: StringWithAggregatesFilter
}

input AssigneesUpdateInput {
  Tasks: TasksUpdateOneRequiredWithoutAssigneesNestedInput
  User: UserUpdateOneRequiredWithoutAssigneesNestedInput
  id: StringFieldUpdateOperationsInput
}

input AssigneesUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
}

input AssigneesUpdateManyWithWhereWithoutTasksInput {
  data: AssigneesUpdateManyMutationInput!
  where: AssigneesScalarWhereInput!
}

input AssigneesUpdateManyWithWhereWithoutUserInput {
  data: AssigneesUpdateManyMutationInput!
  where: AssigneesScalarWhereInput!
}

input AssigneesUpdateManyWithoutTasksNestedInput {
  connect: [AssigneesWhereUniqueInput!]
  connectOrCreate: [AssigneesCreateOrConnectWithoutTasksInput!]
  create: [AssigneesCreateWithoutTasksInput!]
  createMany: AssigneesCreateManyTasksInputEnvelope
  delete: [AssigneesWhereUniqueInput!]
  deleteMany: [AssigneesScalarWhereInput!]
  disconnect: [AssigneesWhereUniqueInput!]
  set: [AssigneesWhereUniqueInput!]
  update: [AssigneesUpdateWithWhereUniqueWithoutTasksInput!]
  updateMany: [AssigneesUpdateManyWithWhereWithoutTasksInput!]
  upsert: [AssigneesUpsertWithWhereUniqueWithoutTasksInput!]
}

input AssigneesUpdateManyWithoutUserNestedInput {
  connect: [AssigneesWhereUniqueInput!]
  connectOrCreate: [AssigneesCreateOrConnectWithoutUserInput!]
  create: [AssigneesCreateWithoutUserInput!]
  createMany: AssigneesCreateManyUserInputEnvelope
  delete: [AssigneesWhereUniqueInput!]
  deleteMany: [AssigneesScalarWhereInput!]
  disconnect: [AssigneesWhereUniqueInput!]
  set: [AssigneesWhereUniqueInput!]
  update: [AssigneesUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [AssigneesUpdateManyWithWhereWithoutUserInput!]
  upsert: [AssigneesUpsertWithWhereUniqueWithoutUserInput!]
}

input AssigneesUpdateWithWhereUniqueWithoutTasksInput {
  data: AssigneesUpdateWithoutTasksInput!
  where: AssigneesWhereUniqueInput!
}

input AssigneesUpdateWithWhereUniqueWithoutUserInput {
  data: AssigneesUpdateWithoutUserInput!
  where: AssigneesWhereUniqueInput!
}

input AssigneesUpdateWithoutTasksInput {
  User: UserUpdateOneRequiredWithoutAssigneesNestedInput
  id: StringFieldUpdateOperationsInput
}

input AssigneesUpdateWithoutUserInput {
  Tasks: TasksUpdateOneRequiredWithoutAssigneesNestedInput
  id: StringFieldUpdateOperationsInput
}

input AssigneesUpsertWithWhereUniqueWithoutTasksInput {
  create: AssigneesCreateWithoutTasksInput!
  update: AssigneesUpdateWithoutTasksInput!
  where: AssigneesWhereUniqueInput!
}

input AssigneesUpsertWithWhereUniqueWithoutUserInput {
  create: AssigneesCreateWithoutUserInput!
  update: AssigneesUpdateWithoutUserInput!
  where: AssigneesWhereUniqueInput!
}

input AssigneesWhereInput {
  AND: [AssigneesWhereInput!]
  NOT: [AssigneesWhereInput!]
  OR: [AssigneesWhereInput!]
  Tasks: TasksRelationFilter
  User: UserRelationFilter
  id: StringFilter
  tasksId: StringFilter
  userId: StringFilter
}

input AssigneesWhereUniqueInput {
  id: String
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

type Comments {
  Tasks: Tasks!
  User: User
  _count: CommentsCount
  children(cursor: CommentsWhereUniqueInput, distinct: [CommentsScalarFieldEnum!], orderBy: [CommentsOrderByWithRelationInput!], skip: Int, take: Int, where: CommentsWhereInput): [Comments!]!
  content: String!
  createdAt: DateTime!
  id: ID!
  ownerId: String!
  parent: Comments
  parentId: String
  targetType: TargetType
  tasksId: String!
  updatedAt: DateTime!
}

type CommentsCount {
  children: Int!
}

type CommentsCountAggregate {
  _all: Int!
  content: Int!
  createdAt: Int!
  id: Int!
  ownerId: Int!
  parentId: Int!
  targetType: Int!
  tasksId: Int!
  updatedAt: Int!
}

input CommentsCountOrderByAggregateInput {
  content: SortOrder
  createdAt: SortOrder
  id: SortOrder
  ownerId: SortOrder
  parentId: SortOrder
  targetType: SortOrder
  tasksId: SortOrder
  updatedAt: SortOrder
}

input CommentsCreateInput {
  Tasks: TasksCreateNestedOneWithoutCommentsInput!
  User: UserCreateNestedOneWithoutCommentsInput
  children: CommentsCreateNestedManyWithoutParentInput
  content: String!
  createdAt: DateTime
  id: String
  parent: CommentsCreateNestedOneWithoutChildrenInput
  targetType: TargetType
  updatedAt: DateTime
}

input CommentsCreateManyInput {
  content: String!
  createdAt: DateTime
  id: String
  ownerId: String!
  parentId: String
  targetType: TargetType
  tasksId: String!
  updatedAt: DateTime
}

input CommentsCreateManyParentInput {
  content: String!
  createdAt: DateTime
  id: String
  ownerId: String!
  targetType: TargetType
  tasksId: String!
  updatedAt: DateTime
}

input CommentsCreateManyParentInputEnvelope {
  data: [CommentsCreateManyParentInput!]!
  skipDuplicates: Boolean
}

input CommentsCreateManyTasksInput {
  content: String!
  createdAt: DateTime
  id: String
  ownerId: String!
  parentId: String
  targetType: TargetType
  updatedAt: DateTime
}

input CommentsCreateManyTasksInputEnvelope {
  data: [CommentsCreateManyTasksInput!]!
  skipDuplicates: Boolean
}

input CommentsCreateManyUserInput {
  content: String!
  createdAt: DateTime
  id: String
  parentId: String
  targetType: TargetType
  tasksId: String!
  updatedAt: DateTime
}

input CommentsCreateManyUserInputEnvelope {
  data: [CommentsCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input CommentsCreateNestedManyWithoutParentInput {
  connect: [CommentsWhereUniqueInput!]
  connectOrCreate: [CommentsCreateOrConnectWithoutParentInput!]
  create: [CommentsCreateWithoutParentInput!]
  createMany: CommentsCreateManyParentInputEnvelope
}

input CommentsCreateNestedManyWithoutTasksInput {
  connect: [CommentsWhereUniqueInput!]
  connectOrCreate: [CommentsCreateOrConnectWithoutTasksInput!]
  create: [CommentsCreateWithoutTasksInput!]
  createMany: CommentsCreateManyTasksInputEnvelope
}

input CommentsCreateNestedManyWithoutUserInput {
  connect: [CommentsWhereUniqueInput!]
  connectOrCreate: [CommentsCreateOrConnectWithoutUserInput!]
  create: [CommentsCreateWithoutUserInput!]
  createMany: CommentsCreateManyUserInputEnvelope
}

input CommentsCreateNestedOneWithoutChildrenInput {
  connect: CommentsWhereUniqueInput
  connectOrCreate: CommentsCreateOrConnectWithoutChildrenInput
  create: CommentsCreateWithoutChildrenInput
}

input CommentsCreateOrConnectWithoutChildrenInput {
  create: CommentsCreateWithoutChildrenInput!
  where: CommentsWhereUniqueInput!
}

input CommentsCreateOrConnectWithoutParentInput {
  create: CommentsCreateWithoutParentInput!
  where: CommentsWhereUniqueInput!
}

input CommentsCreateOrConnectWithoutTasksInput {
  create: CommentsCreateWithoutTasksInput!
  where: CommentsWhereUniqueInput!
}

input CommentsCreateOrConnectWithoutUserInput {
  create: CommentsCreateWithoutUserInput!
  where: CommentsWhereUniqueInput!
}

input CommentsCreateWithoutChildrenInput {
  Tasks: TasksCreateNestedOneWithoutCommentsInput!
  User: UserCreateNestedOneWithoutCommentsInput
  content: String!
  createdAt: DateTime
  id: String
  parent: CommentsCreateNestedOneWithoutChildrenInput
  targetType: TargetType
  updatedAt: DateTime
}

input CommentsCreateWithoutParentInput {
  Tasks: TasksCreateNestedOneWithoutCommentsInput!
  User: UserCreateNestedOneWithoutCommentsInput
  children: CommentsCreateNestedManyWithoutParentInput
  content: String!
  createdAt: DateTime
  id: String
  targetType: TargetType
  updatedAt: DateTime
}

input CommentsCreateWithoutTasksInput {
  User: UserCreateNestedOneWithoutCommentsInput
  children: CommentsCreateNestedManyWithoutParentInput
  content: String!
  createdAt: DateTime
  id: String
  parent: CommentsCreateNestedOneWithoutChildrenInput
  targetType: TargetType
  updatedAt: DateTime
}

input CommentsCreateWithoutUserInput {
  Tasks: TasksCreateNestedOneWithoutCommentsInput!
  children: CommentsCreateNestedManyWithoutParentInput
  content: String!
  createdAt: DateTime
  id: String
  parent: CommentsCreateNestedOneWithoutChildrenInput
  targetType: TargetType
  updatedAt: DateTime
}

type CommentsGroupBy {
  _count: CommentsCountAggregate
  _max: CommentsMaxAggregate
  _min: CommentsMinAggregate
  content: String!
  createdAt: DateTime!
  id: String!
  ownerId: String!
  parentId: String
  targetType: TargetType
  tasksId: String!
  updatedAt: DateTime!
}

input CommentsListRelationFilter {
  every: CommentsWhereInput
  none: CommentsWhereInput
  some: CommentsWhereInput
}

type CommentsMaxAggregate {
  content: String
  createdAt: DateTime
  id: String
  ownerId: String
  parentId: String
  targetType: TargetType
  tasksId: String
  updatedAt: DateTime
}

input CommentsMaxOrderByAggregateInput {
  content: SortOrder
  createdAt: SortOrder
  id: SortOrder
  ownerId: SortOrder
  parentId: SortOrder
  targetType: SortOrder
  tasksId: SortOrder
  updatedAt: SortOrder
}

type CommentsMinAggregate {
  content: String
  createdAt: DateTime
  id: String
  ownerId: String
  parentId: String
  targetType: TargetType
  tasksId: String
  updatedAt: DateTime
}

input CommentsMinOrderByAggregateInput {
  content: SortOrder
  createdAt: SortOrder
  id: SortOrder
  ownerId: SortOrder
  parentId: SortOrder
  targetType: SortOrder
  tasksId: SortOrder
  updatedAt: SortOrder
}

input CommentsOrderByRelationAggregateInput {
  _count: SortOrder
}

input CommentsOrderByWithAggregationInput {
  _count: CommentsCountOrderByAggregateInput
  _max: CommentsMaxOrderByAggregateInput
  _min: CommentsMinOrderByAggregateInput
  content: SortOrder
  createdAt: SortOrder
  id: SortOrder
  ownerId: SortOrder
  parentId: SortOrder
  targetType: SortOrder
  tasksId: SortOrder
  updatedAt: SortOrder
}

input CommentsOrderByWithRelationInput {
  Tasks: TasksOrderByWithRelationInput
  User: UserOrderByWithRelationInput
  children: CommentsOrderByRelationAggregateInput
  content: SortOrder
  createdAt: SortOrder
  id: SortOrder
  ownerId: SortOrder
  parent: CommentsOrderByWithRelationInput
  parentId: SortOrder
  targetType: SortOrder
  tasksId: SortOrder
  updatedAt: SortOrder
}

input CommentsRelationFilter {
  is: CommentsWhereInput
  isNot: CommentsWhereInput
}

enum CommentsScalarFieldEnum {
  content
  createdAt
  id
  ownerId
  parentId
  targetType
  tasksId
  updatedAt
}

input CommentsScalarWhereInput {
  AND: [CommentsScalarWhereInput!]
  NOT: [CommentsScalarWhereInput!]
  OR: [CommentsScalarWhereInput!]
  content: StringFilter
  createdAt: DateTimeFilter
  id: StringFilter
  ownerId: StringFilter
  parentId: StringNullableFilter
  targetType: EnumTargetTypeNullableFilter
  tasksId: StringFilter
  updatedAt: DateTimeFilter
}

input CommentsScalarWhereWithAggregatesInput {
  AND: [CommentsScalarWhereWithAggregatesInput!]
  NOT: [CommentsScalarWhereWithAggregatesInput!]
  OR: [CommentsScalarWhereWithAggregatesInput!]
  content: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  ownerId: StringWithAggregatesFilter
  parentId: StringNullableWithAggregatesFilter
  targetType: EnumTargetTypeNullableWithAggregatesFilter
  tasksId: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

input CommentsUpdateInput {
  Tasks: TasksUpdateOneRequiredWithoutCommentsNestedInput
  User: UserUpdateOneWithoutCommentsNestedInput
  children: CommentsUpdateManyWithoutParentNestedInput
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  parent: CommentsUpdateOneWithoutChildrenNestedInput
  targetType: NullableEnumTargetTypeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CommentsUpdateManyMutationInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  targetType: NullableEnumTargetTypeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CommentsUpdateManyWithWhereWithoutParentInput {
  data: CommentsUpdateManyMutationInput!
  where: CommentsScalarWhereInput!
}

input CommentsUpdateManyWithWhereWithoutTasksInput {
  data: CommentsUpdateManyMutationInput!
  where: CommentsScalarWhereInput!
}

input CommentsUpdateManyWithWhereWithoutUserInput {
  data: CommentsUpdateManyMutationInput!
  where: CommentsScalarWhereInput!
}

input CommentsUpdateManyWithoutParentNestedInput {
  connect: [CommentsWhereUniqueInput!]
  connectOrCreate: [CommentsCreateOrConnectWithoutParentInput!]
  create: [CommentsCreateWithoutParentInput!]
  createMany: CommentsCreateManyParentInputEnvelope
  delete: [CommentsWhereUniqueInput!]
  deleteMany: [CommentsScalarWhereInput!]
  disconnect: [CommentsWhereUniqueInput!]
  set: [CommentsWhereUniqueInput!]
  update: [CommentsUpdateWithWhereUniqueWithoutParentInput!]
  updateMany: [CommentsUpdateManyWithWhereWithoutParentInput!]
  upsert: [CommentsUpsertWithWhereUniqueWithoutParentInput!]
}

input CommentsUpdateManyWithoutTasksNestedInput {
  connect: [CommentsWhereUniqueInput!]
  connectOrCreate: [CommentsCreateOrConnectWithoutTasksInput!]
  create: [CommentsCreateWithoutTasksInput!]
  createMany: CommentsCreateManyTasksInputEnvelope
  delete: [CommentsWhereUniqueInput!]
  deleteMany: [CommentsScalarWhereInput!]
  disconnect: [CommentsWhereUniqueInput!]
  set: [CommentsWhereUniqueInput!]
  update: [CommentsUpdateWithWhereUniqueWithoutTasksInput!]
  updateMany: [CommentsUpdateManyWithWhereWithoutTasksInput!]
  upsert: [CommentsUpsertWithWhereUniqueWithoutTasksInput!]
}

input CommentsUpdateManyWithoutUserNestedInput {
  connect: [CommentsWhereUniqueInput!]
  connectOrCreate: [CommentsCreateOrConnectWithoutUserInput!]
  create: [CommentsCreateWithoutUserInput!]
  createMany: CommentsCreateManyUserInputEnvelope
  delete: [CommentsWhereUniqueInput!]
  deleteMany: [CommentsScalarWhereInput!]
  disconnect: [CommentsWhereUniqueInput!]
  set: [CommentsWhereUniqueInput!]
  update: [CommentsUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [CommentsUpdateManyWithWhereWithoutUserInput!]
  upsert: [CommentsUpsertWithWhereUniqueWithoutUserInput!]
}

input CommentsUpdateOneWithoutChildrenNestedInput {
  connect: CommentsWhereUniqueInput
  connectOrCreate: CommentsCreateOrConnectWithoutChildrenInput
  create: CommentsCreateWithoutChildrenInput
  delete: Boolean
  disconnect: Boolean
  update: CommentsUpdateWithoutChildrenInput
  upsert: CommentsUpsertWithoutChildrenInput
}

input CommentsUpdateWithWhereUniqueWithoutParentInput {
  data: CommentsUpdateWithoutParentInput!
  where: CommentsWhereUniqueInput!
}

input CommentsUpdateWithWhereUniqueWithoutTasksInput {
  data: CommentsUpdateWithoutTasksInput!
  where: CommentsWhereUniqueInput!
}

input CommentsUpdateWithWhereUniqueWithoutUserInput {
  data: CommentsUpdateWithoutUserInput!
  where: CommentsWhereUniqueInput!
}

input CommentsUpdateWithoutChildrenInput {
  Tasks: TasksUpdateOneRequiredWithoutCommentsNestedInput
  User: UserUpdateOneWithoutCommentsNestedInput
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  parent: CommentsUpdateOneWithoutChildrenNestedInput
  targetType: NullableEnumTargetTypeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CommentsUpdateWithoutParentInput {
  Tasks: TasksUpdateOneRequiredWithoutCommentsNestedInput
  User: UserUpdateOneWithoutCommentsNestedInput
  children: CommentsUpdateManyWithoutParentNestedInput
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  targetType: NullableEnumTargetTypeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CommentsUpdateWithoutTasksInput {
  User: UserUpdateOneWithoutCommentsNestedInput
  children: CommentsUpdateManyWithoutParentNestedInput
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  parent: CommentsUpdateOneWithoutChildrenNestedInput
  targetType: NullableEnumTargetTypeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CommentsUpdateWithoutUserInput {
  Tasks: TasksUpdateOneRequiredWithoutCommentsNestedInput
  children: CommentsUpdateManyWithoutParentNestedInput
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  parent: CommentsUpdateOneWithoutChildrenNestedInput
  targetType: NullableEnumTargetTypeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CommentsUpsertWithWhereUniqueWithoutParentInput {
  create: CommentsCreateWithoutParentInput!
  update: CommentsUpdateWithoutParentInput!
  where: CommentsWhereUniqueInput!
}

input CommentsUpsertWithWhereUniqueWithoutTasksInput {
  create: CommentsCreateWithoutTasksInput!
  update: CommentsUpdateWithoutTasksInput!
  where: CommentsWhereUniqueInput!
}

input CommentsUpsertWithWhereUniqueWithoutUserInput {
  create: CommentsCreateWithoutUserInput!
  update: CommentsUpdateWithoutUserInput!
  where: CommentsWhereUniqueInput!
}

input CommentsUpsertWithoutChildrenInput {
  create: CommentsCreateWithoutChildrenInput!
  update: CommentsUpdateWithoutChildrenInput!
}

input CommentsWhereInput {
  AND: [CommentsWhereInput!]
  NOT: [CommentsWhereInput!]
  OR: [CommentsWhereInput!]
  Tasks: TasksRelationFilter
  User: UserRelationFilter
  children: CommentsListRelationFilter
  content: StringFilter
  createdAt: DateTimeFilter
  id: StringFilter
  ownerId: StringFilter
  parent: CommentsRelationFilter
  parentId: StringNullableFilter
  targetType: EnumTargetTypeNullableFilter
  tasksId: StringFilter
  updatedAt: DateTimeFilter
}

input CommentsWhereUniqueInput {
  id: String
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input EnumNameNullableFilter {
  equals: Name
  in: [Name!]
  not: NestedEnumNameNullableFilter
  notIn: [Name!]
}

input EnumNameNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedEnumNameNullableFilter
  _min: NestedEnumNameNullableFilter
  equals: Name
  in: [Name!]
  not: NestedEnumNameNullableWithAggregatesFilter
  notIn: [Name!]
}

input EnumStateFieldUpdateOperationsInput {
  set: State
}

input EnumStateFilter {
  equals: State
  in: [State!]
  not: NestedEnumStateFilter
  notIn: [State!]
}

input EnumStateWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumStateFilter
  _min: NestedEnumStateFilter
  equals: State
  in: [State!]
  not: NestedEnumStateWithAggregatesFilter
  notIn: [State!]
}

input EnumTargetTypeNullableFilter {
  equals: TargetType
  in: [TargetType!]
  not: NestedEnumTargetTypeNullableFilter
  notIn: [TargetType!]
}

input EnumTargetTypeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedEnumTargetTypeNullableFilter
  _min: NestedEnumTargetTypeNullableFilter
  equals: TargetType
  in: [TargetType!]
  not: NestedEnumTargetTypeNullableWithAggregatesFilter
  notIn: [TargetType!]
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

input JsonFilter {
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

input JsonWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedJsonFilter
  _min: NestedJsonFilter
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

type Mutation {
  createManyActions(data: [ActionsCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyAssignees(data: [AssigneesCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyComments(data: [CommentsCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyNotifications(data: [NotificationsCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyTasks(data: [TasksCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUser(data: [UserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneActions(data: ActionsCreateInput!): Actions!
  createOneAssignees(data: AssigneesCreateInput!): Assignees!
  createOneComments(data: CommentsCreateInput!): Comments!
  createOneNotifications(data: NotificationsCreateInput!): Notifications!
  createOneTasks(data: TasksCreateInput!): Tasks!
  createOneUser(data: UserCreateInput!): User!
  deleteManyActions(where: ActionsWhereInput): AffectedRowsOutput!
  deleteManyAssignees(where: AssigneesWhereInput): AffectedRowsOutput!
  deleteManyComments(where: CommentsWhereInput): AffectedRowsOutput!
  deleteManyNotifications(where: NotificationsWhereInput): AffectedRowsOutput!
  deleteManyTasks(where: TasksWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteOneActions(where: ActionsWhereUniqueInput!): Actions
  deleteOneAssignees(where: AssigneesWhereUniqueInput!): Assignees
  deleteOneComments(where: CommentsWhereUniqueInput!): Comments
  deleteOneNotifications(where: NotificationsWhereUniqueInput!): Notifications
  deleteOneTasks(where: TasksWhereUniqueInput!): Tasks
  deleteOneUser(where: UserWhereUniqueInput!): User
  updateManyActions(data: ActionsUpdateManyMutationInput!, where: ActionsWhereInput): AffectedRowsOutput!
  updateManyAssignees(data: AssigneesUpdateManyMutationInput!, where: AssigneesWhereInput): AffectedRowsOutput!
  updateManyComments(data: CommentsUpdateManyMutationInput!, where: CommentsWhereInput): AffectedRowsOutput!
  updateManyNotifications(data: NotificationsUpdateManyMutationInput!, where: NotificationsWhereInput): AffectedRowsOutput!
  updateManyTasks(data: TasksUpdateManyMutationInput!, where: TasksWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateOneActions(data: ActionsUpdateInput!, where: ActionsWhereUniqueInput!): Actions
  updateOneAssignees(data: AssigneesUpdateInput!, where: AssigneesWhereUniqueInput!): Assignees
  updateOneComments(data: CommentsUpdateInput!, where: CommentsWhereUniqueInput!): Comments
  updateOneNotifications(data: NotificationsUpdateInput!, where: NotificationsWhereUniqueInput!): Notifications
  updateOneTasks(data: TasksUpdateInput!, where: TasksWhereUniqueInput!): Tasks
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertOneActions(create: ActionsCreateInput!, update: ActionsUpdateInput!, where: ActionsWhereUniqueInput!): Actions!
  upsertOneAssignees(create: AssigneesCreateInput!, update: AssigneesUpdateInput!, where: AssigneesWhereUniqueInput!): Assignees!
  upsertOneComments(create: CommentsCreateInput!, update: CommentsUpdateInput!, where: CommentsWhereUniqueInput!): Comments!
  upsertOneNotifications(create: NotificationsCreateInput!, update: NotificationsUpdateInput!, where: NotificationsWhereUniqueInput!): Notifications!
  upsertOneTasks(create: TasksCreateInput!, update: TasksUpdateInput!, where: TasksWhereUniqueInput!): Tasks!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

enum Name {
  ADD
  REMOVE
  UPDATE
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedEnumNameNullableFilter {
  equals: Name
  in: [Name!]
  not: NestedEnumNameNullableFilter
  notIn: [Name!]
}

input NestedEnumNameNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedEnumNameNullableFilter
  _min: NestedEnumNameNullableFilter
  equals: Name
  in: [Name!]
  not: NestedEnumNameNullableWithAggregatesFilter
  notIn: [Name!]
}

input NestedEnumStateFilter {
  equals: State
  in: [State!]
  not: NestedEnumStateFilter
  notIn: [State!]
}

input NestedEnumStateWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumStateFilter
  _min: NestedEnumStateFilter
  equals: State
  in: [State!]
  not: NestedEnumStateWithAggregatesFilter
  notIn: [State!]
}

input NestedEnumTargetTypeNullableFilter {
  equals: TargetType
  in: [TargetType!]
  not: NestedEnumTargetTypeNullableFilter
  notIn: [TargetType!]
}

input NestedEnumTargetTypeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedEnumTargetTypeNullableFilter
  _min: NestedEnumTargetTypeNullableFilter
  equals: TargetType
  in: [TargetType!]
  not: NestedEnumTargetTypeNullableWithAggregatesFilter
  notIn: [TargetType!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedJsonFilter {
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Notifications {
  Actions: Actions!
  User: User!
  actionsId: String!
  id: ID!
  readed_at: DateTime!
  userId: String!
}

type NotificationsCountAggregate {
  _all: Int!
  actionsId: Int!
  id: Int!
  readed_at: Int!
  userId: Int!
}

input NotificationsCountOrderByAggregateInput {
  actionsId: SortOrder
  id: SortOrder
  readed_at: SortOrder
  userId: SortOrder
}

input NotificationsCreateInput {
  Actions: ActionsCreateNestedOneWithoutNotificationsInput!
  User: UserCreateNestedOneWithoutNotificationsInput!
  id: String
  readed_at: DateTime!
}

input NotificationsCreateManyActionsInput {
  id: String
  readed_at: DateTime!
  userId: String!
}

input NotificationsCreateManyActionsInputEnvelope {
  data: [NotificationsCreateManyActionsInput!]!
  skipDuplicates: Boolean
}

input NotificationsCreateManyInput {
  actionsId: String!
  id: String
  readed_at: DateTime!
  userId: String!
}

input NotificationsCreateManyUserInput {
  actionsId: String!
  id: String
  readed_at: DateTime!
}

input NotificationsCreateManyUserInputEnvelope {
  data: [NotificationsCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input NotificationsCreateNestedManyWithoutActionsInput {
  connect: [NotificationsWhereUniqueInput!]
  connectOrCreate: [NotificationsCreateOrConnectWithoutActionsInput!]
  create: [NotificationsCreateWithoutActionsInput!]
  createMany: NotificationsCreateManyActionsInputEnvelope
}

input NotificationsCreateNestedManyWithoutUserInput {
  connect: [NotificationsWhereUniqueInput!]
  connectOrCreate: [NotificationsCreateOrConnectWithoutUserInput!]
  create: [NotificationsCreateWithoutUserInput!]
  createMany: NotificationsCreateManyUserInputEnvelope
}

input NotificationsCreateOrConnectWithoutActionsInput {
  create: NotificationsCreateWithoutActionsInput!
  where: NotificationsWhereUniqueInput!
}

input NotificationsCreateOrConnectWithoutUserInput {
  create: NotificationsCreateWithoutUserInput!
  where: NotificationsWhereUniqueInput!
}

input NotificationsCreateWithoutActionsInput {
  User: UserCreateNestedOneWithoutNotificationsInput!
  id: String
  readed_at: DateTime!
}

input NotificationsCreateWithoutUserInput {
  Actions: ActionsCreateNestedOneWithoutNotificationsInput!
  id: String
  readed_at: DateTime!
}

type NotificationsGroupBy {
  _count: NotificationsCountAggregate
  _max: NotificationsMaxAggregate
  _min: NotificationsMinAggregate
  actionsId: String!
  id: String!
  readed_at: DateTime!
  userId: String!
}

input NotificationsListRelationFilter {
  every: NotificationsWhereInput
  none: NotificationsWhereInput
  some: NotificationsWhereInput
}

type NotificationsMaxAggregate {
  actionsId: String
  id: String
  readed_at: DateTime
  userId: String
}

input NotificationsMaxOrderByAggregateInput {
  actionsId: SortOrder
  id: SortOrder
  readed_at: SortOrder
  userId: SortOrder
}

type NotificationsMinAggregate {
  actionsId: String
  id: String
  readed_at: DateTime
  userId: String
}

input NotificationsMinOrderByAggregateInput {
  actionsId: SortOrder
  id: SortOrder
  readed_at: SortOrder
  userId: SortOrder
}

input NotificationsOrderByRelationAggregateInput {
  _count: SortOrder
}

input NotificationsOrderByWithAggregationInput {
  _count: NotificationsCountOrderByAggregateInput
  _max: NotificationsMaxOrderByAggregateInput
  _min: NotificationsMinOrderByAggregateInput
  actionsId: SortOrder
  id: SortOrder
  readed_at: SortOrder
  userId: SortOrder
}

input NotificationsOrderByWithRelationInput {
  Actions: ActionsOrderByWithRelationInput
  User: UserOrderByWithRelationInput
  actionsId: SortOrder
  id: SortOrder
  readed_at: SortOrder
  userId: SortOrder
}

enum NotificationsScalarFieldEnum {
  actionsId
  id
  readed_at
  userId
}

input NotificationsScalarWhereInput {
  AND: [NotificationsScalarWhereInput!]
  NOT: [NotificationsScalarWhereInput!]
  OR: [NotificationsScalarWhereInput!]
  actionsId: StringFilter
  id: StringFilter
  readed_at: DateTimeFilter
  userId: StringFilter
}

input NotificationsScalarWhereWithAggregatesInput {
  AND: [NotificationsScalarWhereWithAggregatesInput!]
  NOT: [NotificationsScalarWhereWithAggregatesInput!]
  OR: [NotificationsScalarWhereWithAggregatesInput!]
  actionsId: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  readed_at: DateTimeWithAggregatesFilter
  userId: StringWithAggregatesFilter
}

input NotificationsUpdateInput {
  Actions: ActionsUpdateOneRequiredWithoutNotificationsNestedInput
  User: UserUpdateOneRequiredWithoutNotificationsNestedInput
  id: StringFieldUpdateOperationsInput
  readed_at: DateTimeFieldUpdateOperationsInput
}

input NotificationsUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  readed_at: DateTimeFieldUpdateOperationsInput
}

input NotificationsUpdateManyWithWhereWithoutActionsInput {
  data: NotificationsUpdateManyMutationInput!
  where: NotificationsScalarWhereInput!
}

input NotificationsUpdateManyWithWhereWithoutUserInput {
  data: NotificationsUpdateManyMutationInput!
  where: NotificationsScalarWhereInput!
}

input NotificationsUpdateManyWithoutActionsNestedInput {
  connect: [NotificationsWhereUniqueInput!]
  connectOrCreate: [NotificationsCreateOrConnectWithoutActionsInput!]
  create: [NotificationsCreateWithoutActionsInput!]
  createMany: NotificationsCreateManyActionsInputEnvelope
  delete: [NotificationsWhereUniqueInput!]
  deleteMany: [NotificationsScalarWhereInput!]
  disconnect: [NotificationsWhereUniqueInput!]
  set: [NotificationsWhereUniqueInput!]
  update: [NotificationsUpdateWithWhereUniqueWithoutActionsInput!]
  updateMany: [NotificationsUpdateManyWithWhereWithoutActionsInput!]
  upsert: [NotificationsUpsertWithWhereUniqueWithoutActionsInput!]
}

input NotificationsUpdateManyWithoutUserNestedInput {
  connect: [NotificationsWhereUniqueInput!]
  connectOrCreate: [NotificationsCreateOrConnectWithoutUserInput!]
  create: [NotificationsCreateWithoutUserInput!]
  createMany: NotificationsCreateManyUserInputEnvelope
  delete: [NotificationsWhereUniqueInput!]
  deleteMany: [NotificationsScalarWhereInput!]
  disconnect: [NotificationsWhereUniqueInput!]
  set: [NotificationsWhereUniqueInput!]
  update: [NotificationsUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [NotificationsUpdateManyWithWhereWithoutUserInput!]
  upsert: [NotificationsUpsertWithWhereUniqueWithoutUserInput!]
}

input NotificationsUpdateWithWhereUniqueWithoutActionsInput {
  data: NotificationsUpdateWithoutActionsInput!
  where: NotificationsWhereUniqueInput!
}

input NotificationsUpdateWithWhereUniqueWithoutUserInput {
  data: NotificationsUpdateWithoutUserInput!
  where: NotificationsWhereUniqueInput!
}

input NotificationsUpdateWithoutActionsInput {
  User: UserUpdateOneRequiredWithoutNotificationsNestedInput
  id: StringFieldUpdateOperationsInput
  readed_at: DateTimeFieldUpdateOperationsInput
}

input NotificationsUpdateWithoutUserInput {
  Actions: ActionsUpdateOneRequiredWithoutNotificationsNestedInput
  id: StringFieldUpdateOperationsInput
  readed_at: DateTimeFieldUpdateOperationsInput
}

input NotificationsUpsertWithWhereUniqueWithoutActionsInput {
  create: NotificationsCreateWithoutActionsInput!
  update: NotificationsUpdateWithoutActionsInput!
  where: NotificationsWhereUniqueInput!
}

input NotificationsUpsertWithWhereUniqueWithoutUserInput {
  create: NotificationsCreateWithoutUserInput!
  update: NotificationsUpdateWithoutUserInput!
  where: NotificationsWhereUniqueInput!
}

input NotificationsWhereInput {
  AND: [NotificationsWhereInput!]
  Actions: ActionsRelationFilter
  NOT: [NotificationsWhereInput!]
  OR: [NotificationsWhereInput!]
  User: UserRelationFilter
  actionsId: StringFilter
  id: StringFilter
  readed_at: DateTimeFilter
  userId: StringFilter
}

input NotificationsWhereUniqueInput {
  id: String
}

input NullableEnumNameFieldUpdateOperationsInput {
  set: Name
}

input NullableEnumTargetTypeFieldUpdateOperationsInput {
  set: TargetType
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Query {
  aggregateActions(cursor: ActionsWhereUniqueInput, orderBy: [ActionsOrderByWithRelationInput!], skip: Int, take: Int, where: ActionsWhereInput): AggregateActions!
  aggregateAssignees(cursor: AssigneesWhereUniqueInput, orderBy: [AssigneesOrderByWithRelationInput!], skip: Int, take: Int, where: AssigneesWhereInput): AggregateAssignees!
  aggregateComments(cursor: CommentsWhereUniqueInput, orderBy: [CommentsOrderByWithRelationInput!], skip: Int, take: Int, where: CommentsWhereInput): AggregateComments!
  aggregateNotifications(cursor: NotificationsWhereUniqueInput, orderBy: [NotificationsOrderByWithRelationInput!], skip: Int, take: Int, where: NotificationsWhereInput): AggregateNotifications!
  aggregateTasks(cursor: TasksWhereUniqueInput, orderBy: [TasksOrderByWithRelationInput!], skip: Int, take: Int, where: TasksWhereInput): AggregateTasks!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  findFirstActions(cursor: ActionsWhereUniqueInput, distinct: [ActionsScalarFieldEnum!], orderBy: [ActionsOrderByWithRelationInput!], skip: Int, take: Int, where: ActionsWhereInput): Actions
  findFirstActionsOrThrow(cursor: ActionsWhereUniqueInput, distinct: [ActionsScalarFieldEnum!], orderBy: [ActionsOrderByWithRelationInput!], skip: Int, take: Int, where: ActionsWhereInput): Actions
  findFirstAssignees(cursor: AssigneesWhereUniqueInput, distinct: [AssigneesScalarFieldEnum!], orderBy: [AssigneesOrderByWithRelationInput!], skip: Int, take: Int, where: AssigneesWhereInput): Assignees
  findFirstAssigneesOrThrow(cursor: AssigneesWhereUniqueInput, distinct: [AssigneesScalarFieldEnum!], orderBy: [AssigneesOrderByWithRelationInput!], skip: Int, take: Int, where: AssigneesWhereInput): Assignees
  findFirstComments(cursor: CommentsWhereUniqueInput, distinct: [CommentsScalarFieldEnum!], orderBy: [CommentsOrderByWithRelationInput!], skip: Int, take: Int, where: CommentsWhereInput): Comments
  findFirstCommentsOrThrow(cursor: CommentsWhereUniqueInput, distinct: [CommentsScalarFieldEnum!], orderBy: [CommentsOrderByWithRelationInput!], skip: Int, take: Int, where: CommentsWhereInput): Comments
  findFirstNotifications(cursor: NotificationsWhereUniqueInput, distinct: [NotificationsScalarFieldEnum!], orderBy: [NotificationsOrderByWithRelationInput!], skip: Int, take: Int, where: NotificationsWhereInput): Notifications
  findFirstNotificationsOrThrow(cursor: NotificationsWhereUniqueInput, distinct: [NotificationsScalarFieldEnum!], orderBy: [NotificationsOrderByWithRelationInput!], skip: Int, take: Int, where: NotificationsWhereInput): Notifications
  findFirstTasks(cursor: TasksWhereUniqueInput, distinct: [TasksScalarFieldEnum!], orderBy: [TasksOrderByWithRelationInput!], skip: Int, take: Int, where: TasksWhereInput): Tasks
  findFirstTasksOrThrow(cursor: TasksWhereUniqueInput, distinct: [TasksScalarFieldEnum!], orderBy: [TasksOrderByWithRelationInput!], skip: Int, take: Int, where: TasksWhereInput): Tasks
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  findFirstUserOrThrow(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  findManyActions(cursor: ActionsWhereUniqueInput, distinct: [ActionsScalarFieldEnum!], orderBy: [ActionsOrderByWithRelationInput!], skip: Int, take: Int, where: ActionsWhereInput): [Actions!]!
  findManyAssignees(cursor: AssigneesWhereUniqueInput, distinct: [AssigneesScalarFieldEnum!], orderBy: [AssigneesOrderByWithRelationInput!], skip: Int, take: Int, where: AssigneesWhereInput): [Assignees!]!
  findManyComments(cursor: CommentsWhereUniqueInput, distinct: [CommentsScalarFieldEnum!], orderBy: [CommentsOrderByWithRelationInput!], skip: Int, take: Int, where: CommentsWhereInput): [Comments!]!
  findManyNotifications(cursor: NotificationsWhereUniqueInput, distinct: [NotificationsScalarFieldEnum!], orderBy: [NotificationsOrderByWithRelationInput!], skip: Int, take: Int, where: NotificationsWhereInput): [Notifications!]!
  findManyTasks(cursor: TasksWhereUniqueInput, distinct: [TasksScalarFieldEnum!], orderBy: [TasksOrderByWithRelationInput!], skip: Int, take: Int, where: TasksWhereInput): [Tasks!]!
  findUniqueActions(where: ActionsWhereUniqueInput!): Actions
  findUniqueActionsOrThrow(where: ActionsWhereUniqueInput!): Actions
  findUniqueAssignees(where: AssigneesWhereUniqueInput!): Assignees
  findUniqueAssigneesOrThrow(where: AssigneesWhereUniqueInput!): Assignees
  findUniqueComments(where: CommentsWhereUniqueInput!): Comments
  findUniqueCommentsOrThrow(where: CommentsWhereUniqueInput!): Comments
  findUniqueNotifications(where: NotificationsWhereUniqueInput!): Notifications
  findUniqueNotificationsOrThrow(where: NotificationsWhereUniqueInput!): Notifications
  findUniqueTasks(where: TasksWhereUniqueInput!): Tasks
  findUniqueTasksOrThrow(where: TasksWhereUniqueInput!): Tasks
  getUser(where: UserWhereUniqueInput!): User
  groupByActions(by: [ActionsScalarFieldEnum!]!, having: ActionsScalarWhereWithAggregatesInput, orderBy: [ActionsOrderByWithAggregationInput!], skip: Int, take: Int, where: ActionsWhereInput): [ActionsGroupBy!]!
  groupByAssignees(by: [AssigneesScalarFieldEnum!]!, having: AssigneesScalarWhereWithAggregatesInput, orderBy: [AssigneesOrderByWithAggregationInput!], skip: Int, take: Int, where: AssigneesWhereInput): [AssigneesGroupBy!]!
  groupByComments(by: [CommentsScalarFieldEnum!]!, having: CommentsScalarWhereWithAggregatesInput, orderBy: [CommentsOrderByWithAggregationInput!], skip: Int, take: Int, where: CommentsWhereInput): [CommentsGroupBy!]!
  groupByNotifications(by: [NotificationsScalarFieldEnum!]!, having: NotificationsScalarWhereWithAggregatesInput, orderBy: [NotificationsOrderByWithAggregationInput!], skip: Int, take: Int, where: NotificationsWhereInput): [NotificationsGroupBy!]!
  groupByTasks(by: [TasksScalarFieldEnum!]!, having: TasksScalarWhereWithAggregatesInput, orderBy: [TasksOrderByWithAggregationInput!], skip: Int, take: Int, where: TasksWhereInput): [TasksGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

enum SortOrder {
  asc
  desc
}

enum State {
  CREATED
  FINISHED
  PROGRESS
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Subscription {
  hello: String!
}

enum TargetType {
  TASK
}

type Tasks {
  Actions(cursor: ActionsWhereUniqueInput, distinct: [ActionsScalarFieldEnum!], orderBy: [ActionsOrderByWithRelationInput!], skip: Int, take: Int, where: ActionsWhereInput): [Actions!]!
  Assignees(cursor: AssigneesWhereUniqueInput, distinct: [AssigneesScalarFieldEnum!], orderBy: [AssigneesOrderByWithRelationInput!], skip: Int, take: Int, where: AssigneesWhereInput): [Assignees!]!
  Comments(cursor: CommentsWhereUniqueInput, distinct: [CommentsScalarFieldEnum!], orderBy: [CommentsOrderByWithRelationInput!], skip: Int, take: Int, where: CommentsWhereInput): [Comments!]!
  _count: TasksCount
  createdAt: DateTime!
  date: DateTime!
  description: String
  id: ID!
  ownerId: User!
  state: State!
  title: String!
  updatedAt: DateTime!
  userId: String!
}

type TasksCount {
  Actions: Int!
  Assignees: Int!
  Comments: Int!
}

type TasksCountAggregate {
  _all: Int!
  createdAt: Int!
  date: Int!
  description: Int!
  id: Int!
  state: Int!
  title: Int!
  updatedAt: Int!
  userId: Int!
}

input TasksCountOrderByAggregateInput {
  createdAt: SortOrder
  date: SortOrder
  description: SortOrder
  id: SortOrder
  state: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input TasksCreateInput {
  Actions: ActionsCreateNestedManyWithoutTasksInput
  Assignees: AssigneesCreateNestedManyWithoutTasksInput
  Comments: CommentsCreateNestedManyWithoutTasksInput
  createdAt: DateTime
  date: DateTime!
  description: String
  id: String
  ownerId: UserCreateNestedOneWithoutTasksInput!
  state: State
  title: String!
  updatedAt: DateTime
}

input TasksCreateManyInput {
  createdAt: DateTime
  date: DateTime!
  description: String
  id: String
  state: State
  title: String!
  updatedAt: DateTime
  userId: String!
}

input TasksCreateManyOwnerIdInput {
  createdAt: DateTime
  date: DateTime!
  description: String
  id: String
  state: State
  title: String!
  updatedAt: DateTime
}

input TasksCreateManyOwnerIdInputEnvelope {
  data: [TasksCreateManyOwnerIdInput!]!
  skipDuplicates: Boolean
}

input TasksCreateNestedManyWithoutOwnerIdInput {
  connect: [TasksWhereUniqueInput!]
  connectOrCreate: [TasksCreateOrConnectWithoutOwnerIdInput!]
  create: [TasksCreateWithoutOwnerIdInput!]
  createMany: TasksCreateManyOwnerIdInputEnvelope
}

input TasksCreateNestedOneWithoutActionsInput {
  connect: TasksWhereUniqueInput
  connectOrCreate: TasksCreateOrConnectWithoutActionsInput
  create: TasksCreateWithoutActionsInput
}

input TasksCreateNestedOneWithoutAssigneesInput {
  connect: TasksWhereUniqueInput
  connectOrCreate: TasksCreateOrConnectWithoutAssigneesInput
  create: TasksCreateWithoutAssigneesInput
}

input TasksCreateNestedOneWithoutCommentsInput {
  connect: TasksWhereUniqueInput
  connectOrCreate: TasksCreateOrConnectWithoutCommentsInput
  create: TasksCreateWithoutCommentsInput
}

input TasksCreateOrConnectWithoutActionsInput {
  create: TasksCreateWithoutActionsInput!
  where: TasksWhereUniqueInput!
}

input TasksCreateOrConnectWithoutAssigneesInput {
  create: TasksCreateWithoutAssigneesInput!
  where: TasksWhereUniqueInput!
}

input TasksCreateOrConnectWithoutCommentsInput {
  create: TasksCreateWithoutCommentsInput!
  where: TasksWhereUniqueInput!
}

input TasksCreateOrConnectWithoutOwnerIdInput {
  create: TasksCreateWithoutOwnerIdInput!
  where: TasksWhereUniqueInput!
}

input TasksCreateWithoutActionsInput {
  Assignees: AssigneesCreateNestedManyWithoutTasksInput
  Comments: CommentsCreateNestedManyWithoutTasksInput
  createdAt: DateTime
  date: DateTime!
  description: String
  id: String
  ownerId: UserCreateNestedOneWithoutTasksInput!
  state: State
  title: String!
  updatedAt: DateTime
}

input TasksCreateWithoutAssigneesInput {
  Actions: ActionsCreateNestedManyWithoutTasksInput
  Comments: CommentsCreateNestedManyWithoutTasksInput
  createdAt: DateTime
  date: DateTime!
  description: String
  id: String
  ownerId: UserCreateNestedOneWithoutTasksInput!
  state: State
  title: String!
  updatedAt: DateTime
}

input TasksCreateWithoutCommentsInput {
  Actions: ActionsCreateNestedManyWithoutTasksInput
  Assignees: AssigneesCreateNestedManyWithoutTasksInput
  createdAt: DateTime
  date: DateTime!
  description: String
  id: String
  ownerId: UserCreateNestedOneWithoutTasksInput!
  state: State
  title: String!
  updatedAt: DateTime
}

input TasksCreateWithoutOwnerIdInput {
  Actions: ActionsCreateNestedManyWithoutTasksInput
  Assignees: AssigneesCreateNestedManyWithoutTasksInput
  Comments: CommentsCreateNestedManyWithoutTasksInput
  createdAt: DateTime
  date: DateTime!
  description: String
  id: String
  state: State
  title: String!
  updatedAt: DateTime
}

type TasksGroupBy {
  _count: TasksCountAggregate
  _max: TasksMaxAggregate
  _min: TasksMinAggregate
  createdAt: DateTime!
  date: DateTime!
  description: String
  id: String!
  state: State!
  title: String!
  updatedAt: DateTime!
  userId: String!
}

input TasksListRelationFilter {
  every: TasksWhereInput
  none: TasksWhereInput
  some: TasksWhereInput
}

type TasksMaxAggregate {
  createdAt: DateTime
  date: DateTime
  description: String
  id: String
  state: State
  title: String
  updatedAt: DateTime
  userId: String
}

input TasksMaxOrderByAggregateInput {
  createdAt: SortOrder
  date: SortOrder
  description: SortOrder
  id: SortOrder
  state: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

type TasksMinAggregate {
  createdAt: DateTime
  date: DateTime
  description: String
  id: String
  state: State
  title: String
  updatedAt: DateTime
  userId: String
}

input TasksMinOrderByAggregateInput {
  createdAt: SortOrder
  date: SortOrder
  description: SortOrder
  id: SortOrder
  state: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input TasksOrderByRelationAggregateInput {
  _count: SortOrder
}

input TasksOrderByWithAggregationInput {
  _count: TasksCountOrderByAggregateInput
  _max: TasksMaxOrderByAggregateInput
  _min: TasksMinOrderByAggregateInput
  createdAt: SortOrder
  date: SortOrder
  description: SortOrder
  id: SortOrder
  state: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input TasksOrderByWithRelationInput {
  Actions: ActionsOrderByRelationAggregateInput
  Assignees: AssigneesOrderByRelationAggregateInput
  Comments: CommentsOrderByRelationAggregateInput
  createdAt: SortOrder
  date: SortOrder
  description: SortOrder
  id: SortOrder
  ownerId: UserOrderByWithRelationInput
  state: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input TasksRelationFilter {
  is: TasksWhereInput
  isNot: TasksWhereInput
}

enum TasksScalarFieldEnum {
  createdAt
  date
  description
  id
  state
  title
  updatedAt
  userId
}

input TasksScalarWhereInput {
  AND: [TasksScalarWhereInput!]
  NOT: [TasksScalarWhereInput!]
  OR: [TasksScalarWhereInput!]
  createdAt: DateTimeFilter
  date: DateTimeFilter
  description: StringNullableFilter
  id: StringFilter
  state: EnumStateFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  userId: StringFilter
}

input TasksScalarWhereWithAggregatesInput {
  AND: [TasksScalarWhereWithAggregatesInput!]
  NOT: [TasksScalarWhereWithAggregatesInput!]
  OR: [TasksScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  date: DateTimeWithAggregatesFilter
  description: StringNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  state: EnumStateWithAggregatesFilter
  title: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: StringWithAggregatesFilter
}

input TasksUpdateInput {
  Actions: ActionsUpdateManyWithoutTasksNestedInput
  Assignees: AssigneesUpdateManyWithoutTasksNestedInput
  Comments: CommentsUpdateManyWithoutTasksNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  ownerId: UserUpdateOneRequiredWithoutTasksNestedInput
  state: EnumStateFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TasksUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  state: EnumStateFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TasksUpdateManyWithWhereWithoutOwnerIdInput {
  data: TasksUpdateManyMutationInput!
  where: TasksScalarWhereInput!
}

input TasksUpdateManyWithoutOwnerIdNestedInput {
  connect: [TasksWhereUniqueInput!]
  connectOrCreate: [TasksCreateOrConnectWithoutOwnerIdInput!]
  create: [TasksCreateWithoutOwnerIdInput!]
  createMany: TasksCreateManyOwnerIdInputEnvelope
  delete: [TasksWhereUniqueInput!]
  deleteMany: [TasksScalarWhereInput!]
  disconnect: [TasksWhereUniqueInput!]
  set: [TasksWhereUniqueInput!]
  update: [TasksUpdateWithWhereUniqueWithoutOwnerIdInput!]
  updateMany: [TasksUpdateManyWithWhereWithoutOwnerIdInput!]
  upsert: [TasksUpsertWithWhereUniqueWithoutOwnerIdInput!]
}

input TasksUpdateOneRequiredWithoutActionsNestedInput {
  connect: TasksWhereUniqueInput
  connectOrCreate: TasksCreateOrConnectWithoutActionsInput
  create: TasksCreateWithoutActionsInput
  update: TasksUpdateWithoutActionsInput
  upsert: TasksUpsertWithoutActionsInput
}

input TasksUpdateOneRequiredWithoutAssigneesNestedInput {
  connect: TasksWhereUniqueInput
  connectOrCreate: TasksCreateOrConnectWithoutAssigneesInput
  create: TasksCreateWithoutAssigneesInput
  update: TasksUpdateWithoutAssigneesInput
  upsert: TasksUpsertWithoutAssigneesInput
}

input TasksUpdateOneRequiredWithoutCommentsNestedInput {
  connect: TasksWhereUniqueInput
  connectOrCreate: TasksCreateOrConnectWithoutCommentsInput
  create: TasksCreateWithoutCommentsInput
  update: TasksUpdateWithoutCommentsInput
  upsert: TasksUpsertWithoutCommentsInput
}

input TasksUpdateWithWhereUniqueWithoutOwnerIdInput {
  data: TasksUpdateWithoutOwnerIdInput!
  where: TasksWhereUniqueInput!
}

input TasksUpdateWithoutActionsInput {
  Assignees: AssigneesUpdateManyWithoutTasksNestedInput
  Comments: CommentsUpdateManyWithoutTasksNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  ownerId: UserUpdateOneRequiredWithoutTasksNestedInput
  state: EnumStateFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TasksUpdateWithoutAssigneesInput {
  Actions: ActionsUpdateManyWithoutTasksNestedInput
  Comments: CommentsUpdateManyWithoutTasksNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  ownerId: UserUpdateOneRequiredWithoutTasksNestedInput
  state: EnumStateFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TasksUpdateWithoutCommentsInput {
  Actions: ActionsUpdateManyWithoutTasksNestedInput
  Assignees: AssigneesUpdateManyWithoutTasksNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  ownerId: UserUpdateOneRequiredWithoutTasksNestedInput
  state: EnumStateFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TasksUpdateWithoutOwnerIdInput {
  Actions: ActionsUpdateManyWithoutTasksNestedInput
  Assignees: AssigneesUpdateManyWithoutTasksNestedInput
  Comments: CommentsUpdateManyWithoutTasksNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  state: EnumStateFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TasksUpsertWithWhereUniqueWithoutOwnerIdInput {
  create: TasksCreateWithoutOwnerIdInput!
  update: TasksUpdateWithoutOwnerIdInput!
  where: TasksWhereUniqueInput!
}

input TasksUpsertWithoutActionsInput {
  create: TasksCreateWithoutActionsInput!
  update: TasksUpdateWithoutActionsInput!
}

input TasksUpsertWithoutAssigneesInput {
  create: TasksCreateWithoutAssigneesInput!
  update: TasksUpdateWithoutAssigneesInput!
}

input TasksUpsertWithoutCommentsInput {
  create: TasksCreateWithoutCommentsInput!
  update: TasksUpdateWithoutCommentsInput!
}

input TasksWhereInput {
  AND: [TasksWhereInput!]
  Actions: ActionsListRelationFilter
  Assignees: AssigneesListRelationFilter
  Comments: CommentsListRelationFilter
  NOT: [TasksWhereInput!]
  OR: [TasksWhereInput!]
  createdAt: DateTimeFilter
  date: DateTimeFilter
  description: StringNullableFilter
  id: StringFilter
  ownerId: UserRelationFilter
  state: EnumStateFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  userId: StringFilter
}

input TasksWhereUniqueInput {
  id: String
}

type User {
  Assignees(cursor: AssigneesWhereUniqueInput, distinct: [AssigneesScalarFieldEnum!], orderBy: [AssigneesOrderByWithRelationInput!], skip: Int, take: Int, where: AssigneesWhereInput): [Assignees!]!
  Comments(cursor: CommentsWhereUniqueInput, distinct: [CommentsScalarFieldEnum!], orderBy: [CommentsOrderByWithRelationInput!], skip: Int, take: Int, where: CommentsWhereInput): [Comments!]!
  Notifications(cursor: NotificationsWhereUniqueInput, distinct: [NotificationsScalarFieldEnum!], orderBy: [NotificationsOrderByWithRelationInput!], skip: Int, take: Int, where: NotificationsWhereInput): [Notifications!]!
  Tasks(cursor: TasksWhereUniqueInput, distinct: [TasksScalarFieldEnum!], orderBy: [TasksOrderByWithRelationInput!], skip: Int, take: Int, where: TasksWhereInput): [Tasks!]!
  _count: UserCount
  active: Boolean!
  createdAt: DateTime!
  email: String!
  id: ID!
  last_sign_in_at: DateTime!
  name: String!
  password_digest: String!
  preferences: JSON!
  updatedAt: DateTime!
}

type UserCount {
  Assignees: Int!
  Comments: Int!
  Notifications: Int!
  Tasks: Int!
}

type UserCountAggregate {
  _all: Int!
  active: Int!
  createdAt: Int!
  email: Int!
  id: Int!
  last_sign_in_at: Int!
  name: Int!
  password_digest: Int!
  preferences: Int!
  updatedAt: Int!
}

input UserCountOrderByAggregateInput {
  active: SortOrder
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  last_sign_in_at: SortOrder
  name: SortOrder
  password_digest: SortOrder
  preferences: SortOrder
  updatedAt: SortOrder
}

input UserCreateInput {
  Assignees: AssigneesCreateNestedManyWithoutUserInput
  Comments: CommentsCreateNestedManyWithoutUserInput
  Notifications: NotificationsCreateNestedManyWithoutUserInput
  Tasks: TasksCreateNestedManyWithoutOwnerIdInput
  active: Boolean!
  createdAt: DateTime
  email: String!
  id: String
  last_sign_in_at: DateTime!
  name: String!
  password_digest: String!
  preferences: JSON!
  updatedAt: DateTime
}

input UserCreateManyInput {
  active: Boolean!
  createdAt: DateTime
  email: String!
  id: String
  last_sign_in_at: DateTime!
  name: String!
  password_digest: String!
  preferences: JSON!
  updatedAt: DateTime
}

input UserCreateNestedOneWithoutAssigneesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutAssigneesInput
  create: UserCreateWithoutAssigneesInput
}

input UserCreateNestedOneWithoutCommentsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutCommentsInput
  create: UserCreateWithoutCommentsInput
}

input UserCreateNestedOneWithoutNotificationsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutNotificationsInput
  create: UserCreateWithoutNotificationsInput
}

input UserCreateNestedOneWithoutTasksInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutTasksInput
  create: UserCreateWithoutTasksInput
}

input UserCreateOrConnectWithoutAssigneesInput {
  create: UserCreateWithoutAssigneesInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutNotificationsInput {
  create: UserCreateWithoutNotificationsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutTasksInput {
  create: UserCreateWithoutTasksInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutAssigneesInput {
  Comments: CommentsCreateNestedManyWithoutUserInput
  Notifications: NotificationsCreateNestedManyWithoutUserInput
  Tasks: TasksCreateNestedManyWithoutOwnerIdInput
  active: Boolean!
  createdAt: DateTime
  email: String!
  id: String
  last_sign_in_at: DateTime!
  name: String!
  password_digest: String!
  preferences: JSON!
  updatedAt: DateTime
}

input UserCreateWithoutCommentsInput {
  Assignees: AssigneesCreateNestedManyWithoutUserInput
  Notifications: NotificationsCreateNestedManyWithoutUserInput
  Tasks: TasksCreateNestedManyWithoutOwnerIdInput
  active: Boolean!
  createdAt: DateTime
  email: String!
  id: String
  last_sign_in_at: DateTime!
  name: String!
  password_digest: String!
  preferences: JSON!
  updatedAt: DateTime
}

input UserCreateWithoutNotificationsInput {
  Assignees: AssigneesCreateNestedManyWithoutUserInput
  Comments: CommentsCreateNestedManyWithoutUserInput
  Tasks: TasksCreateNestedManyWithoutOwnerIdInput
  active: Boolean!
  createdAt: DateTime
  email: String!
  id: String
  last_sign_in_at: DateTime!
  name: String!
  password_digest: String!
  preferences: JSON!
  updatedAt: DateTime
}

input UserCreateWithoutTasksInput {
  Assignees: AssigneesCreateNestedManyWithoutUserInput
  Comments: CommentsCreateNestedManyWithoutUserInput
  Notifications: NotificationsCreateNestedManyWithoutUserInput
  active: Boolean!
  createdAt: DateTime
  email: String!
  id: String
  last_sign_in_at: DateTime!
  name: String!
  password_digest: String!
  preferences: JSON!
  updatedAt: DateTime
}

type UserGroupBy {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  active: Boolean!
  createdAt: DateTime!
  email: String!
  id: String!
  last_sign_in_at: DateTime!
  name: String!
  password_digest: String!
  preferences: JSON!
  updatedAt: DateTime!
}

type UserMaxAggregate {
  active: Boolean
  createdAt: DateTime
  email: String
  id: String
  last_sign_in_at: DateTime
  name: String
  password_digest: String
  updatedAt: DateTime
}

input UserMaxOrderByAggregateInput {
  active: SortOrder
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  last_sign_in_at: SortOrder
  name: SortOrder
  password_digest: SortOrder
  updatedAt: SortOrder
}

type UserMinAggregate {
  active: Boolean
  createdAt: DateTime
  email: String
  id: String
  last_sign_in_at: DateTime
  name: String
  password_digest: String
  updatedAt: DateTime
}

input UserMinOrderByAggregateInput {
  active: SortOrder
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  last_sign_in_at: SortOrder
  name: SortOrder
  password_digest: SortOrder
  updatedAt: SortOrder
}

input UserOrderByWithAggregationInput {
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  active: SortOrder
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  last_sign_in_at: SortOrder
  name: SortOrder
  password_digest: SortOrder
  preferences: SortOrder
  updatedAt: SortOrder
}

input UserOrderByWithRelationInput {
  Assignees: AssigneesOrderByRelationAggregateInput
  Comments: CommentsOrderByRelationAggregateInput
  Notifications: NotificationsOrderByRelationAggregateInput
  Tasks: TasksOrderByRelationAggregateInput
  active: SortOrder
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  last_sign_in_at: SortOrder
  name: SortOrder
  password_digest: SortOrder
  preferences: SortOrder
  updatedAt: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  active
  createdAt
  email
  id
  last_sign_in_at
  name
  password_digest
  preferences
  updatedAt
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  active: BoolWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  email: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  last_sign_in_at: DateTimeWithAggregatesFilter
  name: StringWithAggregatesFilter
  password_digest: StringWithAggregatesFilter
  preferences: JsonWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

input UserUpdateInput {
  Assignees: AssigneesUpdateManyWithoutUserNestedInput
  Comments: CommentsUpdateManyWithoutUserNestedInput
  Notifications: NotificationsUpdateManyWithoutUserNestedInput
  Tasks: TasksUpdateManyWithoutOwnerIdNestedInput
  active: BoolFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  last_sign_in_at: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password_digest: StringFieldUpdateOperationsInput
  preferences: JSON
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  active: BoolFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  last_sign_in_at: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password_digest: StringFieldUpdateOperationsInput
  preferences: JSON
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutAssigneesNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutAssigneesInput
  create: UserCreateWithoutAssigneesInput
  update: UserUpdateWithoutAssigneesInput
  upsert: UserUpsertWithoutAssigneesInput
}

input UserUpdateOneRequiredWithoutNotificationsNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutNotificationsInput
  create: UserCreateWithoutNotificationsInput
  update: UserUpdateWithoutNotificationsInput
  upsert: UserUpsertWithoutNotificationsInput
}

input UserUpdateOneRequiredWithoutTasksNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutTasksInput
  create: UserCreateWithoutTasksInput
  update: UserUpdateWithoutTasksInput
  upsert: UserUpsertWithoutTasksInput
}

input UserUpdateOneWithoutCommentsNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutCommentsInput
  create: UserCreateWithoutCommentsInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutCommentsInput
  upsert: UserUpsertWithoutCommentsInput
}

input UserUpdateWithoutAssigneesInput {
  Comments: CommentsUpdateManyWithoutUserNestedInput
  Notifications: NotificationsUpdateManyWithoutUserNestedInput
  Tasks: TasksUpdateManyWithoutOwnerIdNestedInput
  active: BoolFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  last_sign_in_at: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password_digest: StringFieldUpdateOperationsInput
  preferences: JSON
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateWithoutCommentsInput {
  Assignees: AssigneesUpdateManyWithoutUserNestedInput
  Notifications: NotificationsUpdateManyWithoutUserNestedInput
  Tasks: TasksUpdateManyWithoutOwnerIdNestedInput
  active: BoolFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  last_sign_in_at: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password_digest: StringFieldUpdateOperationsInput
  preferences: JSON
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateWithoutNotificationsInput {
  Assignees: AssigneesUpdateManyWithoutUserNestedInput
  Comments: CommentsUpdateManyWithoutUserNestedInput
  Tasks: TasksUpdateManyWithoutOwnerIdNestedInput
  active: BoolFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  last_sign_in_at: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password_digest: StringFieldUpdateOperationsInput
  preferences: JSON
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateWithoutTasksInput {
  Assignees: AssigneesUpdateManyWithoutUserNestedInput
  Comments: CommentsUpdateManyWithoutUserNestedInput
  Notifications: NotificationsUpdateManyWithoutUserNestedInput
  active: BoolFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  last_sign_in_at: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password_digest: StringFieldUpdateOperationsInput
  preferences: JSON
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpsertWithoutAssigneesInput {
  create: UserCreateWithoutAssigneesInput!
  update: UserUpdateWithoutAssigneesInput!
}

input UserUpsertWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput!
  update: UserUpdateWithoutCommentsInput!
}

input UserUpsertWithoutNotificationsInput {
  create: UserCreateWithoutNotificationsInput!
  update: UserUpdateWithoutNotificationsInput!
}

input UserUpsertWithoutTasksInput {
  create: UserCreateWithoutTasksInput!
  update: UserUpdateWithoutTasksInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  Assignees: AssigneesListRelationFilter
  Comments: CommentsListRelationFilter
  NOT: [UserWhereInput!]
  Notifications: NotificationsListRelationFilter
  OR: [UserWhereInput!]
  Tasks: TasksListRelationFilter
  active: BoolFilter
  createdAt: DateTimeFilter
  email: StringFilter
  id: StringFilter
  last_sign_in_at: DateTimeFilter
  name: StringFilter
  password_digest: StringFilter
  preferences: JsonFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  id: String
}